using System;
using System.IO;
using System.Collections.Generic;
namespace PuzzleSolver
{
    class Parser
    {
        private string file;
        public List<Tile> pieces;
        public List<int[,]> color_codes;
        public Tile solution;
        public int smallest;
        public int code;
//Read the file (file is currently hardcoded in), return all the lines as an array of strings
        public string[] ReadFile()
        {
            StreamReader reader = File.OpenText(file);
            string line;
            List<string> all_lines = new List<string>();
            while ((line = reader.ReadLine()) != null) {
                all_lines.Add(line);
                }
            return all_lines.ToArray();
        }
//Basic constructer, takes in file_name and creates pieces List
        public Parser(string file_name){
            file = file_name;
            code = 0;
            pieces = new List<Tile>();
            color_codes = new List<int[,]>();
        }
//Takes the string array of all lines, finds the number of rows and the max row length to create rectangular 2D array
//Transfers the string array into the 2D array of chars, iterates through each char in the array, if the char is significant, send it to CreateTile()
//Result of CreateTile() is used in the constructor of a new Tile()
        public void Parse() {
        string[] all_lines = ReadFile();
        int col_length = all_lines.Length;
        int row_length = all_lines[0].Length;
        foreach (string s in all_lines){
            if(row_length < s.Length){
                row_length = s.Length;
                }
            }
        char[,] lines = new char[col_length, row_length];
        int i = 0;
        int j = 0;
        foreach (string s in all_lines){
            j=0;
            foreach (char c in s) {
                lines[i,j] = c;
                j++;
                }
                for(int k = j; k < row_length; k++) {
                    lines[i,k] = ' ';
                }
            i++;
            }
        for(int n = 0; n < col_length; n++){
            for(int m = 0; m < row_length; m++){
                if(lines[n,m] != ' '){
                    char[,] new_tile = new char[col_length, row_length];
                    for(int q = 0; q < col_length; q++){
                        for(int w = 0; w < row_length; w++){
                            new_tile[q,w] = ' ';
                        }
                    }
                    CreateTile(new_tile, lines, n, m, col_length, row_length);
                    Tile t = new Tile(new_tile, row_length, col_length, code);
                    code += 1;
                    pieces.Add(t);
                    }
                }
            }
            pieces.Sort();
        }
        public void PrintSol(char[,] running_sol){
            for(int i = 0; i < running_sol.GetLength(0); i++){
                for(int j = 0; j < running_sol.GetLength(1); j++){
                    Console.Write(running_sol[i,j]);
                }
                Console.WriteLine();
            }
            Console.WriteLine();
            Console.ReadKey();
        }
//Recursive function, takes an all space 2D array and the parsed 2D array (same size), the two indices, and the array sizes (for convenience)
//Changes the value at i,j in tile to the value at i,j in all_tiles, sets that value to be insignificant in all_tiles, then checks all relevant directions
//For the significance of the char at each of those spots, calling itself on that char if that char is significant
        public void CreateTile(char[,] tile, char[,] all_tiles, int i, int j, int cl, int rl) {
            tile[i,j] = all_tiles[i,j];
            all_tiles[i,j] = ' ';
            if(i>0){
                if(all_tiles[i-1,j] != ' '){
                    CreateTile(tile, all_tiles, i-1, j, cl, rl);
                }
            }
            if(j>0){
                if(all_tiles[i,j-1] != ' '){
                    CreateTile(tile, all_tiles, i, j-1, cl, rl);
                }
            }
            if(i<(cl-1)){
                if(all_tiles[i+1,j] != ' '){
                    CreateTile(tile, all_tiles, i+1, j, cl, rl);
                }
            }
            if(j<(rl-1)){
                if(all_tiles[i,j+1] != ' '){
                    CreateTile(tile, all_tiles, i, j+1, cl, rl);
                }
            }
        }
//Check all the sizes of tiles to see if solution tile is the same size or smaller than sum of other tiles
//If smaller, check to see if equal to some sum of other tile sizes
//Also sets largest tile as the solution piece
        public int CheckSizes(){
            pieces[pieces.Count-1].solution = true;
            solution = pieces[pieces.Count-1];
            smallest = pieces[0].size;
            int sol_co = pieces[pieces.Count-1].csize;
            int sol_ro = pieces[pieces.Count-1].rsize;
            foreach(Tile t in pieces){
                t.sol_c = sol_co;
                t.sol_r = sol_ro;
                t.FindOrientations(t.dimensions, t.csize, t.rsize);
                t.FindPositions();
            }
            int sol_size = pieces[pieces.Count -1].size;
            int sum = 0;
            for(int i = 0; i < pieces.Count-1 ; i++){
                sum += pieces[i].size;
            }
            if(sum == sol_size){
                return 1;
            }
            else if(sum < sol_size){
                return -1;
            }
            else{
 /*             int diff = sum - sol_size;
                List<Tile> removable_tiles = new List<Tile>;
                if(pieces[0].size > diff){
                    return -1;
                }
                foreach(Tile t in pieces){
                    if(t.size == diff){
                        return 0;
                    }
                    else if(t.size < diff){
                        
                    } */
                return 0; 
            }
        }
        public void CheckDuplicateTiles(){
            for(int i = 1; i < pieces.Count; i++)
                if(pieces[i].size == pieces[i-1].size){
                    pieces[i].CheckIsomorphic(pieces[i-1]);
                }
        }
//Recursive function to check every combination of tile placements. Starting from the biggest tile, from each position that tile can take it calls the
//function on the next biggest tile. If at any point there is overlap, the tile is removed and the next possible branch is explored.
//Once a possible solution is found, it is checked against the solution tile and added (if valid) to the solution list which is returned
        public List<char[,]> SolutionRecursion(List<Tile> pieces, List<char[,]> solutions, char [,] running_solution, int[,] running_colors, int csize, int rsize){
            List<Tile> smaller_pieces = new List<Tile>();
            for(int t = 1; t < pieces.Count; t++){
                smaller_pieces.Add(pieces[t]);
            }
            Tile biggest = pieces[0];
            bool found = false;
            for(int g = 0; g < biggest.orientations.Count; g++){
                for(int i = 0; i < biggest.orientations[g].c_off; i++){
                    for(int j = 0; j < biggest.orientations[g].r_off; j++){
                        if(biggest.PlaceInSolution(running_solution, running_colors, i, j, g)){
                            if(solution.RunningCheck(running_solution)){
                                biggest.RemoveFromSolution(running_solution, running_colors, i, j, g);
                                continue;
                            }
                            if(smaller_pieces.Count == 0){
                                if(solution.CheckValid(running_solution)&&solution.CheckNewSolution(running_colors, color_codes)){
                                    char [,] new_solution = new char[csize, rsize];
                                    int [,] new_colors = new int[csize, rsize];
                                    for(int n = 0; n < csize; n++){
                                        for(int m = 0; m < rsize; m++){
                                            new_solution[n,m] = running_solution[n,m];
                                            new_colors[n,m] = running_colors[n,m];
                                        }
                                    }
                                    solutions.Add(new_solution);
                                    color_codes.Add(new_colors);
                                    found = true;
                                }
                                biggest.RemoveFromSolution(running_solution, running_colors, i, j, g);
                                if(found){
                                    break;
                                }
                            }
                            else{
                                SolutionRecursion(smaller_pieces, solutions, running_solution, running_colors, csize, rsize);
                                biggest.RemoveFromSolution(running_solution, running_colors, i, j, g);
                            }
                        }
                    if(found){
                        found = false;
                        break;
                    }
                    }
                if(found){
                    found = false;
                    break;
                }
                }
            }
            return solutions;
        }
    }
    class ParseTester{
        static void Main(){
            Parser p = new Parser("C:\\Users\\Xeny\\trivial.txt");
            p.Parse();
            int i = p.CheckSizes();
            if(i == -1){
                Console.WriteLine("No solution possible");
            }
            else if(i == 0){
                Console.WriteLine("Some pieces may not be used if a solution is found");
            }
            p.CheckDuplicateTiles();
            List<Tile> options = new List<Tile>();
            char[,] blank_sol = new char[p.solution.csize, p.solution.rsize];
            int[,] blank_colors = new int[p.solution.csize, p.solution.rsize];
            for(int k = 0; k < p.solution.csize; k++){
                for(int j = 0; j < p.solution.rsize; j++){
                    blank_sol[k,j] = ' ';
                    blank_colors[k,j] = -1;
                }
            }
            foreach(Tile t in p.pieces){
                if(t.solution == false){
                    options.Add(t);
                }
            }
            options.Reverse();
            List<char[,]> found_solutions = new List<char[,]>();
            List<char[,]> solus = p.SolutionRecursion(options, found_solutions, blank_sol, blank_colors, p.solution.csize, p.solution.rsize);
            for(int x = 0; x < solus.Count; x++){
                Console.WriteLine("Solution "+(x+1));
                for(int y = 0; y < p.solution.csize; y++){
                    for(int z = 0; z < p.solution.rsize; z++){
                        Console.Write(solus[x][y,z]);
                    }
                    Console.WriteLine();
                }
            }
            for(int q = 0; q < p.color_codes.Count; q++){
                Console.WriteLine("Color_Codes "+(q+1));
                for(int s = 0; s < p.solution.csize; s++){
                    for(int f = 0; f < p.solution.rsize; f++){
                        Console.Write(p.color_codes[q][s,f]);
                    }
                    Console.WriteLine();
                }
            }
            Console.ReadKey();
            Console.ReadKey();
            Console.WriteLine("Finished");
            Console.ReadKey();
        }
    }
}