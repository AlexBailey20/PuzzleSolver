using System;
using System.IO;
using System.Collections.Generic;
namespace PuzzleSolver
{
    class Parser
    {
        private string file;
        private List<Tile> pieces;
//Read the file (file is currently hardcoded in), return all the lines as an array of strings
        public string[] ReadFile()
        {
            StreamReader reader = File.OpenText(file);
            string line;
            List<string> all_lines = new List<string>();
            while ((line = reader.ReadLine()) != null) {
                all_lines.Add(line);
                }
            return all_lines.ToArray();
        }
//Basic constructer, takes in file_name and creates pieces List
        public Parser(string file_name){
            file = file_name;
            pieces = new List<Tile>();
        }
//Takes the string array of all lines, finds the number of rows and the max row length to create rectangular 2D array
//Transfers the string array into the 2D array of chars, iterates through each char in the array, if the char is significant, send it to CreateTile()
//Result of CreateTile() is used in the constructor of a new Tile()
        public void Parse() {
        string[] all_lines = ReadFile();
        int col_length = all_lines.Length;
        int row_length = all_lines[0].Length;
        foreach (string s in all_lines){
            if(row_length < s.Length){
                row_length = s.Length;
                }
            }
        char[,] lines = new char[col_length, row_length];
        int i = 0;
        int j = 0;
        foreach (string s in all_lines){
            j=0;
            foreach (char c in s) {
                lines[i,j] = c;
                j++;
                }
                for(int k = j; k < row_length; k++) {
                    lines[i,k] = ' ';
                }
            i++;
            }
        for(int n = 0; n < col_length; n++){
            for(int m = 0; m < row_length; m++){
                if(lines[n,m] != ' '){
                    char[,] new_tile = new char[col_length, row_length];
                    for(int q = 0; q < col_length; q++){
                        for(int w = 0; w < row_length; w++){
                            new_tile[q,w] = ' ';
                        }
                    }
                    CreateTile(new_tile, lines, n, m, col_length, row_length);
                    Tile t = new Tile(new_tile, row_length, col_length);
                    pieces.Add(t);
                    }
                }
            }
            pieces.Sort();
        }
//Recursive function, takes an all space 2D array and the parsed 2D array (same size), the two indices, and the array sizes (for convenience)
//Changes the value at i,j in tile to the value at i,j in all_tiles, sets that value to be insignificant in all_tiles, then checks all relevant directions
//For the significance of the char at each of those spots, calling itself on that char if that char is significant
        public void CreateTile(char[,] tile, char[,] all_tiles, int i, int j, int cl, int rl) {
            tile[i,j] = all_tiles[i,j];
            all_tiles[i,j] = ' ';
            if(i>0){
                if(all_tiles[i-1,j] != ' '){
                    CreateTile(tile, all_tiles, i-1, j, cl, rl);
                }
            }
            if(j>0){
                if(all_tiles[i,j-1] != ' '){
                    CreateTile(tile, all_tiles, i, j-1, cl, rl);
                }
            }
            if(i<(cl-1)){
                if(all_tiles[i+1,j] != ' '){
                    CreateTile(tile, all_tiles, i+1, j, cl, rl);
                }
            }
            if(j<(rl-1)){
                if(all_tiles[i,j+1] != ' '){
                    CreateTile(tile, all_tiles, i, j+1, cl, rl);
                }
            }
        }
//Check all the sizes of tiles to see if solution tile is the same size or smaller than sum of other tiles
//If smaller, check to see if equal to some sum of other tile sizes
//Also sets largest tile as the solution piece
        public int CheckSizes(){
            pieces[pieces.Count-1].solution = true;
            int sol_co = pieces[pieces.Count-1].csize;
            int sol_ro = pieces[pieces.Count-1].rsize;
            foreach(Tile t in pieces){
                t.sol_c = sol_co;
                t.sol_r = sol_ro;
                t.FindPositions();
            }
            int sol_size = pieces[pieces.Count -1].size;
            int sum = 0;
            for(int i = 0; i < pieces.Count-1 ; i++){
                sum += pieces[i].size;
            }
            if(sum == sol_size){
                return 1;
            }
            else if(sum < sol_size){
                return -1;
            }
            else{
 /*             int diff = sum - sol_size;
                List<Tile> removable_tiles = new List<Tile>;
                if(pieces[0].size > diff){
                    return -1;
                }
                foreach(Tile t in pieces){
                    if(t.size == diff){
                        return 0;
                    }
                    else if(t.size < diff){
                        
                    } */
                return 0; 
            }
        }
//CURRENTLY: Finds all possible solutions given all possible placements of the tiles on the solutions space
//FUTURE: Checks validity of solution, removes possible solutions which already are shown to be impossible
//FUTURE: Implements rotations and reflections
//FUTURE: Checks to eliminate repeated solutions
        public void FindSolutions(){
            List<Tile> options = new List<Tile>();
            Tile solution = pieces[pieces.Count -1];
            int pot_sol = 1;
            foreach(Tile t in pieces){
                if(t.solution == false){
                    options.Add(t);
                }
            }
            foreach(Tile t in options){
                pot_sol = pot_sol * t.positions;
            }
            int repeats = pot_sol;
            List<char[,]> running_sols = new List<char[,]>();
            Console.WriteLine(pot_sol);
            for(int k = 0; k < pot_sol; k++){
                char[,] blank_sol = new char[solution.csize, solution.rsize];
                for(int i = 0; i < solution.csize; i++){
                    for(int j = 0; j < solution.rsize; j++){
                        blank_sol[i,j] = ' ';
                    }
                }
                running_sols.Add(blank_sol);
            }
            options.Reverse();
            int sec_repeat = 1;
            foreach(Tile t in options){
                Console.WriteLine(t.c_off);
                Console.WriteLine(t.r_off);
                repeats = repeats/t.positions;
                Console.WriteLine(repeats);
                Console.ReadKey();
                int itr = 0;
                for(int v = 0; v < sec_repeat; v++){
                    for(int n = 0; n < t.c_off; n++){
                        for(int m = 0; m < t.r_off; m++){
                            for(int r = 0; r < repeats; r++){
                                t.PlaceInSolution(running_sols[itr], n, m);
                                itr++;
                            }
                        }
                    }
                }
                sec_repeat = t.positions;
            }
            for(int x = 0; x < 48; x++){
                for(int a = 0; a < solution.csize; a++){
                    for(int b = 0; b < solution.rsize; b++){
                        Console.Write(running_sols[x][a,b]);
                    }
                    Console.WriteLine();
                }
                Console.WriteLine();
            }  
            Console.ReadKey(); 
        } 
    }
    class ParseTester{
        static void Main(){
            Parser p = new Parser("C:\\Users\\Xeny\\trivial.txt");
            p.Parse();
            int i = p.CheckSizes();
            if(i == -1){
                Console.WriteLine("No solution possible");
            }
            else if(i == 0){
                Console.WriteLine("Some pieces may not be used if a solution is found");
            }
            p.FindSolutions();
        }
    }
}